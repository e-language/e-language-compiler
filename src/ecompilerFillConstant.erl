%%% this is the 1st pass, ast generated by yeec file is handled by this module

-module(ecompilerFillConstant).

-export([parseAndRemoveConstants/1]).

-include("./ecompilerFrameDef.hrl").

%% find all consts in AST, calculate it and replace all const references.
parseAndRemoveConstants(Ast) ->
    {Constants, Ast2} = prvFetchContants(Ast),
    Ast3 = prvReplaceContants(Ast2, Constants),
    %io:format(">>> ~p~n", [Ast3]),
    Ast3.

%% fetch constants
prvFetchContants(Ast) -> prvFetchContants(Ast, [], #{}).

prvFetchContants([#const{name = Name, val = Expr} | Rest], Statements, Constants) ->
    prvFetchContants(Rest, Statements, Constants#{Name => prvEvaluateConstantExpression(Expr, Constants)});
prvFetchContants([Any | Rest], Statements, Constants) ->
    prvFetchContants(Rest, [Any | Statements], Constants);
prvFetchContants([], Statements, Constants) ->
    {Constants, lists:reverse(Statements)}.

prvEvaluateConstantExpression(#op2{operator = '+', op1 = Op1, op2 = Op2}, Constants) ->
    prvEvaluateConstantExpression(Op1, Constants) + prvEvaluateConstantExpression(Op2, Constants);
prvEvaluateConstantExpression(#op2{operator = '-', op1 = Op1, op2 = Op2}, Constants) ->
    prvEvaluateConstantExpression(Op1, Constants) - prvEvaluateConstantExpression(Op2, Constants);
prvEvaluateConstantExpression(#op2{operator = '*', op1 = Op1, op2 = Op2}, Constants) ->
    prvEvaluateConstantExpression(Op1, Constants) * prvEvaluateConstantExpression(Op2, Constants);
prvEvaluateConstantExpression(#op2{operator = '/', op1 = Op1, op2 = Op2}, Constants) ->
    prvEvaluateConstantExpression(Op1, Constants) / prvEvaluateConstantExpression(Op2, Constants);
prvEvaluateConstantExpression(#op2{operator = 'rem', op1 = Op1, op2 = Op2}, Constants) ->
    prvEvaluateConstantExpression(Op1, Constants) rem prvEvaluateConstantExpression(Op2, Constants);
prvEvaluateConstantExpression(#op2{operator = 'and', op1 = Op1, op2 = Op2}, Constants) ->
    (prvEvaluateConstantExpression(Op1, Constants) =/= 0) and (prvEvaluateConstantExpression(Op2, Constants) =/= 0);
prvEvaluateConstantExpression(#op2{operator = 'or', op1 = Op1, op2 = Op2}, Constants) ->
    (prvEvaluateConstantExpression(Op1, Constants) =:= 1) or (prvEvaluateConstantExpression(Op2, Constants) =:= 1);
prvEvaluateConstantExpression(#op2{operator = 'band', op1 = Op1, op2 = Op2}, Constants) ->
    prvEvaluateConstantExpression(Op1, Constants) band prvEvaluateConstantExpression(Op2, Constants);
prvEvaluateConstantExpression(#op2{operator = 'bor', op1 = Op1, op2 = Op2}, Constants) ->
    prvEvaluateConstantExpression(Op1, Constants) bor prvEvaluateConstantExpression(Op2, Constants);
prvEvaluateConstantExpression(#op2{operator = 'bxor', op1 = Op1, op2 = Op2}, Constants) ->
    prvEvaluateConstantExpression(Op1, Constants) bxor prvEvaluateConstantExpression(Op2, Constants);
prvEvaluateConstantExpression(#op2{operator = 'bsr', op1 = Op1, op2 = Op2}, Constants) ->
    prvEvaluateConstantExpression(Op1, Constants) bsr prvEvaluateConstantExpression(Op2, Constants);
prvEvaluateConstantExpression(#op2{operator = 'bsl', op1 = Op1, op2 = Op2}, Constants) ->
    prvEvaluateConstantExpression(Op1, Constants) bsl prvEvaluateConstantExpression(Op2, Constants);
prvEvaluateConstantExpression(#varref{name = Name, line = Line}, Constants) ->
    case maps:find(Name, Constants) of
        error ->
            throw({Line, ecompilerUtil:flatfmt("undefined constant ~s", [Name])});
        {ok, Val} ->
            Val
    end;
prvEvaluateConstantExpression({ImmiType, _, Val}, _) when ImmiType =:= integer; ImmiType =:= float ->
    Val;
prvEvaluateConstantExpression(Num, _) when is_integer(Num); is_float(Num) ->
    Num;
prvEvaluateConstantExpression(Any, _) ->
    throw(ecompilerUtil:flatfmt("invalid const expression: ~p", [Any])).

%% replace constants in AST
prvReplaceContants([#function_raw{params = Params, exprs = Exprs} = Fn | Rest], Constants) ->
    [Fn#function_raw{params = prvReplaceContantsInExpressions(Params, Constants), exprs = prvReplaceContantsInExpressions(Exprs, Constants)} | prvReplaceContants(Rest, Constants)];
prvReplaceContants([#struct_raw{fields = Fields} = S | Rest], Constants) ->
    [S#struct_raw{fields = prvReplaceContantsInExpressions(Fields, Constants)} | prvReplaceContants(Rest, Constants)];
prvReplaceContants([#vardef{type = Type, initval = Initval} = V | Rest], Constants) ->
    [V#vardef{type = prvReplaceConstantsInType(Type, Constants), initval = prvReplaceContantsInExpression(Initval, Constants)} | prvReplaceContants(Rest, Constants)];
prvReplaceContants([], _) ->
    [].

prvReplaceContantsInExpressions(Exprs, Constants) ->
    ecompilerUtil:expressionMap(fun (E) -> prvReplaceContantsInExpression(E, Constants) end, Exprs).

prvReplaceContantsInExpression(#vardef{name = Name, initval = Initval, type = Type, line = Line} = Expr, Constants) ->
    case maps:find(Name, Constants) of
        {ok, _} ->
            throw({Line, ecompilerUtil:flatfmt("~s conflicts with const", [Name])});
        error ->
            Expr#vardef{initval = prvReplaceContantsInExpression(Initval, Constants), type = prvReplaceConstantsInType(Type, Constants)}
    end;
prvReplaceContantsInExpression(#varref{name = Name, line = Line} = Expr, Constants) ->
    case maps:find(Name, Constants) of
        {ok, Val} ->
            prvConstantNumberToToken(Val, Line);
        error ->
            Expr
    end;
prvReplaceContantsInExpression(#struct_init_raw{fields = Fields} = Expr, Constants) ->
    Expr#struct_init_raw{fields = prvReplaceContantsInExpressions(Fields, Constants)};
prvReplaceContantsInExpression(#array_init{elements = Elements} = Expr, Constants) ->
    Expr#array_init{elements = prvReplaceContantsInExpressions(Elements, Constants)};
prvReplaceContantsInExpression(#op2{op1 = Op1, op2 = Op2} = Expr, Constants) ->
    Expr#op2{op1 = prvReplaceContantsInExpression(Op1, Constants), op2 = prvReplaceContantsInExpression(Op2, Constants)};
prvReplaceContantsInExpression(#op1{operand = Operand} = Expr, Constants) ->
    Expr#op1{operand = prvReplaceContantsInExpression(Operand, Constants)};
prvReplaceContantsInExpression(Any, _) ->
    Any.

prvConstantNumberToToken(Num, Line) when is_float(Num) -> #float{val = Num, line = Line};
prvConstantNumberToToken(Num, Line) when is_integer(Num) -> #integer{val = Num, line = Line}.

prvReplaceConstantsInType(#array_type{elemtype = ElementType, len = Len} = T, Constants) ->
    T#array_type{elemtype = prvReplaceConstantsInType(ElementType, Constants), len = prvEvaluateConstantExpression(prvReplaceContantsInExpression(Len, Constants), Constants)};
prvReplaceConstantsInType(Any, _) ->
    Any.

