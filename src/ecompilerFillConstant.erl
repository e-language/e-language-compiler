%%% this is the 1st pass, ast generated by yeec file is handled by this module

-module(ecompilerFillConstant).

-export([parseAndRemoveConstants/1]).

-include("./ecompilerFrameDef.hrl").

%% find all consts in AST, calculate it and replace all const references.
parseAndRemoveConstants(AST) ->
    {Constants, Ast2} = prvFetchContants(AST),
    Ast3 = prvReplaceContants(Ast2, Constants),
    %io:format(">>> ~p~n", [Ast3]),
    Ast3.

%% fetch constants
prvFetchContants(AST) -> prvFetchContants(AST, [], #{}).

prvFetchContants([#const{name = Name, val = Expression} | Rest], Statements, Constants) ->
    prvFetchContants(Rest, Statements, Constants#{Name => prvEvaluateConstantExpression(Expression, Constants)});
prvFetchContants([Any | Rest], Statements, Constants) ->
    prvFetchContants(Rest, [Any | Statements], Constants);
prvFetchContants([], Statements, Constants) ->
    {Constants, lists:reverse(Statements)}.

prvEvaluateConstantExpression(#op2{operator = '+', op1 = Operand1, op2 = Operand2}, Constants) ->
    prvEvaluateConstantExpression(Operand1, Constants) + prvEvaluateConstantExpression(Operand2, Constants);
prvEvaluateConstantExpression(#op2{operator = '-', op1 = Operand1, op2 = Operand2}, Constants) ->
    prvEvaluateConstantExpression(Operand1, Constants) - prvEvaluateConstantExpression(Operand2, Constants);
prvEvaluateConstantExpression(#op2{operator = '*', op1 = Operand1, op2 = Operand2}, Constants) ->
    prvEvaluateConstantExpression(Operand1, Constants) * prvEvaluateConstantExpression(Operand2, Constants);
prvEvaluateConstantExpression(#op2{operator = '/', op1 = Operand1, op2 = Operand2}, Constants) ->
    prvEvaluateConstantExpression(Operand1, Constants) / prvEvaluateConstantExpression(Operand2, Constants);
prvEvaluateConstantExpression(#op2{operator = 'rem', op1 = Operand1, op2 = Operand2}, Constants) ->
    prvEvaluateConstantExpression(Operand1, Constants) rem prvEvaluateConstantExpression(Operand2, Constants);
prvEvaluateConstantExpression(#op2{operator = 'and', op1 = Operand1, op2 = Operand2}, Constants) ->
    (prvEvaluateConstantExpression(Operand1, Constants) =/= 0) and (prvEvaluateConstantExpression(Operand2, Constants) =/= 0);
prvEvaluateConstantExpression(#op2{operator = 'or', op1 = Operand1, op2 = Operand2}, Constants) ->
    (prvEvaluateConstantExpression(Operand1, Constants) =:= 1) or (prvEvaluateConstantExpression(Operand2, Constants) =:= 1);
prvEvaluateConstantExpression(#op2{operator = 'band', op1 = Operand1, op2 = Operand2}, Constants) ->
    prvEvaluateConstantExpression(Operand1, Constants) band prvEvaluateConstantExpression(Operand2, Constants);
prvEvaluateConstantExpression(#op2{operator = 'bor', op1 = Operand1, op2 = Operand2}, Constants) ->
    prvEvaluateConstantExpression(Operand1, Constants) bor prvEvaluateConstantExpression(Operand2, Constants);
prvEvaluateConstantExpression(#op2{operator = 'bxor', op1 = Operand1, op2 = Operand2}, Constants) ->
    prvEvaluateConstantExpression(Operand1, Constants) bxor prvEvaluateConstantExpression(Operand2, Constants);
prvEvaluateConstantExpression(#op2{operator = 'bsr', op1 = Operand1, op2 = Operand2}, Constants) ->
    prvEvaluateConstantExpression(Operand1, Constants) bsr prvEvaluateConstantExpression(Operand2, Constants);
prvEvaluateConstantExpression(#op2{operator = 'bsl', op1 = Operand1, op2 = Operand2}, Constants) ->
    prvEvaluateConstantExpression(Operand1, Constants) bsl prvEvaluateConstantExpression(Operand2, Constants);
prvEvaluateConstantExpression(#varref{name = Name, line = Line}, Constants) ->
    case maps:find(Name, Constants) of
        {ok, Val}   -> Val;
        error       -> throw({Line, ecompilerUtil:flatfmt("undefined constant ~s", [Name])})
    end;
prvEvaluateConstantExpression({ImmiType, _, Val}, _) when ImmiType =:= integer; ImmiType =:= float ->
    Val;
prvEvaluateConstantExpression(Num, _) when is_integer(Num); is_float(Num) ->
    Num;
prvEvaluateConstantExpression(Any, _) ->
    throw(ecompilerUtil:flatfmt("invalid const expression: ~p", [Any])).

%% replace constants in AST
prvReplaceContants([#function_raw{params = Params, exprs = Expressions} = Fn | Rest], Constants) ->
    [Fn#function_raw{params = prvReplaceContantsInExpressions(Params, Constants), exprs = prvReplaceContantsInExpressions(Expressions, Constants)} | prvReplaceContants(Rest, Constants)];
prvReplaceContants([#struct_raw{fields = Fields} = S | Rest], Constants) ->
    [S#struct_raw{fields = prvReplaceContantsInExpressions(Fields, Constants)} | prvReplaceContants(Rest, Constants)];
prvReplaceContants([#vardef{type = Type, initval = Initval} = V | Rest], Constants) ->
    [V#vardef{type = prvReplaceConstantsInType(Type, Constants), initval = prvReplaceContantsInExpression(Initval, Constants)} | prvReplaceContants(Rest, Constants)];
prvReplaceContants([], _) ->
    [].

prvReplaceContantsInExpressions(Expressions, Constants) ->
    ecompilerUtil:expressionMap(fun (E) -> prvReplaceContantsInExpression(E, Constants) end, Expressions).

prvReplaceContantsInExpression(#vardef{name = Name, initval = Initval, type = Type, line = Line} = Expression, Constants) ->
    case maps:find(Name, Constants) of
        {ok, _}     -> throw({Line, ecompilerUtil:flatfmt("~s conflicts with const", [Name])});
        error       -> Expression#vardef{initval = prvReplaceContantsInExpression(Initval, Constants), type = prvReplaceConstantsInType(Type, Constants)}
    end;
prvReplaceContantsInExpression(#varref{name = Name, line = Line} = Expression, Constants) ->
    case maps:find(Name, Constants) of
        {ok, Val}   -> prvConstantNumberToToken(Val, Line);
        error       -> Expression
    end;
prvReplaceContantsInExpression(#struct_init_raw{fields = Fields} = Expression, Constants) ->
    Expression#struct_init_raw{fields = prvReplaceContantsInExpressions(Fields, Constants)};
prvReplaceContantsInExpression(#array_init{elements = Elements} = Expression, Constants) ->
    Expression#array_init{elements = prvReplaceContantsInExpressions(Elements, Constants)};
prvReplaceContantsInExpression(#op2{op1 = Operand1, op2 = Operand2} = Expression, Constants) ->
    Expression#op2{op1 = prvReplaceContantsInExpression(Operand1, Constants), op2 = prvReplaceContantsInExpression(Operand2, Constants)};
prvReplaceContantsInExpression(#op1{operand = Operand} = Expression, Constants) ->
    Expression#op1{operand = prvReplaceContantsInExpression(Operand, Constants)};
prvReplaceContantsInExpression(Any, _) ->
    Any.

prvConstantNumberToToken(Num, Line) when is_float(Num)      -> #float{val = Num, line = Line};
prvConstantNumberToToken(Num, Line) when is_integer(Num)    -> #integer{val = Num, line = Line}.

prvReplaceConstantsInType(#array_type{elemtype = ElementType, len = Len} = T, Constants) ->
    T#array_type{elemtype = prvReplaceConstantsInType(ElementType, Constants), len = prvEvaluateConstantExpression( prvReplaceContantsInExpression(Len, Constants),  Constants )};
prvReplaceConstantsInType(Any, _) ->
    Any.