%%% this is the 1st pass, ast generated by yeec file is handled by this module

-module('ecompilerFillConstant.erl').

-export([parseAndRemoveConstants/1]).

-include("ecompilerFrameDef.hrl").

%% find all consts in AST, calculate it and replace all const references.
parseAndRemoveConstants(AST) ->
    {Constants, AST2} = fetchContants(AST),
    AST3 = replaceContants(AST2, Constants),
    %io:format(">>> ~p~n", [AST3]),
    AST3.

%% fetch constants
fetchContants(AST) ->
    fetchContants(AST, [], #{}).

fetchContants([#const{name = Name, value = Expression} | Rest], Statements, Constants) ->
    fetchContants(Rest, Statements, Constants#{Name => evaluateConstantExpression(Expression, Constants)});
fetchContants([Any | Rest], Statements, Constants) ->
    fetchContants(Rest, [Any | Statements], Constants);
fetchContants([], Statements, Constants) ->
    {Constants, lists:reverse(Statements)}.

evaluateConstantExpression(#operatorExpression2{operator = '+', operand1 = Operand1, operand2 = Operand2}, Constants) ->
    evaluateConstantExpression(Operand1, Constants) + evaluateConstantExpression(Operand2, Constants);
evaluateConstantExpression(#operatorExpression2{operator = '-', operand1 = Operand1, operand2 = Operand2}, Constants) ->
    evaluateConstantExpression(Operand1, Constants) - evaluateConstantExpression(Operand2, Constants);
evaluateConstantExpression(#operatorExpression2{operator = '*', operand1 = Operand1, operand2 = Operand2}, Constants) ->
    evaluateConstantExpression(Operand1, Constants) * evaluateConstantExpression(Operand2, Constants);
evaluateConstantExpression(#operatorExpression2{operator = '/', operand1 = Operand1, operand2 = Operand2}, Constants) ->
    evaluateConstantExpression(Operand1, Constants) / evaluateConstantExpression(Operand2, Constants);
evaluateConstantExpression(#operatorExpression2{operator = 'rem', operand1 = Operand1, operand2 = Operand2}, Constants) ->
    evaluateConstantExpression(Operand1, Constants) rem evaluateConstantExpression(Operand2, Constants);
evaluateConstantExpression(#operatorExpression2{operator = 'and', operand1 = Operand1, operand2 = Operand2}, Constants) ->
    (evaluateConstantExpression(Operand1, Constants) =/= 0) and (evaluateConstantExpression(Operand2, Constants) =/= 0);
evaluateConstantExpression(#operatorExpression2{operator = 'or', operand1 = Operand1, operand2 = Operand2}, Constants) ->
    (evaluateConstantExpression(Operand1, Constants) =:= 1) or (evaluateConstantExpression(Operand2, Constants) =:= 1);
evaluateConstantExpression(#operatorExpression2{operator = 'band', operand1 = Operand1, operand2 = Operand2}, Constants) ->
    evaluateConstantExpression(Operand1, Constants) band evaluateConstantExpression(Operand2, Constants);
evaluateConstantExpression(#operatorExpression2{operator = 'bor', operand1 = Operand1, operand2 = Operand2}, Constants) ->
    evaluateConstantExpression(Operand1, Constants) bor evaluateConstantExpression(Operand2, Constants);
evaluateConstantExpression(#operatorExpression2{operator = 'bxor', operand1 = Operand1, operand2 = Operand2}, Constants) ->
    evaluateConstantExpression(Operand1, Constants) bxor evaluateConstantExpression(Operand2, Constants);
evaluateConstantExpression(#operatorExpression2{operator = 'bsr', operand1 = Operand1, operand2 = Operand2}, Constants) ->
    evaluateConstantExpression(Operand1, Constants) bsr evaluateConstantExpression(Operand2, Constants);
evaluateConstantExpression(#operatorExpression2{operator = 'bsl', operand1 = Operand1, operand2 = Operand2}, Constants) ->
    evaluateConstantExpression(Operand1, Constants) bsl evaluateConstantExpression(Operand2, Constants);
evaluateConstantExpression(#variableReference{name = Name, line = Line}, Constants) ->
    case maps:find(Name, Constants) of
        {ok, Val} ->
            Val;
        error ->
            throw({Line, ecompilerUtil:fmt("undefined constant ~s", [Name])})
    end;
evaluateConstantExpression({ImmiType, _, Val}, _) when ImmiType =:= integer; ImmiType =:= float ->
    Val;
evaluateConstantExpression(Num, _) when is_integer(Num); is_float(Num) ->
    Num;
evaluateConstantExpression(Any, _) ->
    throw(ecompilerUtil:fmt("invalid const expression: ~p", [Any])).

%% replace constants in AST
replaceContants([#functionRaw{parameters = Params, exprs = Expressions} = Fn | Rest], Constants) ->
    [Fn#functionRaw{parameters = replaceContantsInExpressions(Params, Constants), exprs = replaceContantsInExpressions(Expressions, Constants)} | replaceContants(Rest, Constants)];
replaceContants([#structRaw{fields = Fields} = S | Rest], Constants) ->
    [S#structRaw{fields = replaceContantsInExpressions(Fields, Constants)} | replaceContants(Rest, Constants)];
replaceContants([#variableDefinition{type = Type, initialValue = Initval} = V | Rest], Constants) ->
    [V#variableDefinition{type = replaceConstantsInType(Type, Constants), initialValue = replaceContantsInExpression(Initval, Constants)} | replaceContants(Rest, Constants)];
replaceContants([], _) ->
    [].

replaceContantsInExpressions(Expressions, Constants) ->
    ecompilerUtil:expressionMap(fun (E) -> replaceContantsInExpression(E, Constants) end, Expressions).

replaceContantsInExpression(#variableDefinition{name = Name, initialValue = Initval, type = Type, line = Line} = Expression, Constants) ->
    case maps:find(Name, Constants) of
        {ok, _} ->
            throw({Line, ecompilerUtil:fmt("~s conflicts with const", [Name])});
        error ->
            Expression#variableDefinition{initialValue = replaceContantsInExpression(Initval, Constants), type = replaceConstantsInType(Type, Constants)}
    end;
replaceContantsInExpression(#variableReference{name = Name, line = Line} = Expression, Constants) ->
    case maps:find(Name, Constants) of
        {ok, Val} ->
            constantNumberToToken(Val, Line);
        error ->
            Expression
    end;
replaceContantsInExpression(#structInitializeExpressionRaw{fields = Fields} = Expression, Constants) ->
    Expression#structInitializeExpressionRaw{fields = replaceContantsInExpressions(Fields, Constants)};
replaceContantsInExpression(#arrayInitializeExpression{elements = Elements} = Expression, Constants) ->
    Expression#arrayInitializeExpression{elements = replaceContantsInExpressions(Elements, Constants)};
replaceContantsInExpression(#operatorExpression2{operand1 = Operand1, operand2 = Operand2} = Expression, Constants) ->
    Expression#operatorExpression2{operand1 = replaceContantsInExpression(Operand1, Constants), operand2 = replaceContantsInExpression(Operand2, Constants)};
replaceContantsInExpression(#operatorExpression1{operand = Operand} = Expression, Constants) ->
    Expression#operatorExpression1{operand = replaceContantsInExpression(Operand, Constants)};
replaceContantsInExpression(Any, _) ->
    Any.

constantNumberToToken(Num, Line) when is_float(Num) ->
    #float{value = Num, line = Line};
constantNumberToToken(Num, Line) when is_integer(Num) ->
    #integer{value = Num, line = Line}.

replaceConstantsInType(#arrayType{elemtype = ElementType, length = Len} = T, Constants) ->
    T#arrayType{elemtype = replaceConstantsInType(ElementType, Constants), length = evaluateConstantExpression(replaceContantsInExpression(Len, Constants), Constants)};
replaceConstantsInType(Any, _) ->
    Any.
